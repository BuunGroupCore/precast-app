import fs from "fs/promises";
import path from "path";

import { consola } from "consola";
import { logger } from "../utils/logger.js";

import { type ProjectConfig } from "../../../shared/stack-config.js";

import { getPluginManager } from "@/core/plugin-manager.js";
import { createTemplateEngine } from "@/core/template-engine.js";
import { generateBackendTemplate } from "@/generators/backend-generator.js";
import { getTemplateRoot } from "@/utils/template-path.js";

/**
 * Generate package.json file for a project
 * @param config - Project configuration
 * @param projectPath - Project directory path
 * @param dependencies - Runtime dependencies
 * @param devDependencies - Development dependencies
 * @param additionalFields - Additional package.json fields
 */
export async function generatePackageJson(
  config: ProjectConfig,
  projectPath: string,
  dependencies: string[] = [],
  devDependencies: string[] = [],
  additionalFields: Record<string, any> = {}
): Promise<void> {
  const packageJson = {
    name: config.name,
    version: "0.1.0",
    private: true,
    description: `${config.framework} application generated by create-precast-app`,
    ...additionalFields,
    dependencies: dependencies.reduce(
      (acc, dep) => {
        acc[dep] = "latest";
        return acc;
      },
      {} as Record<string, string>
    ),
    devDependencies: devDependencies.reduce(
      (acc, dep) => {
        acc[dep] = "latest";
        return acc;
      },
      {} as Record<string, string>
    ),
  };

  await fs.writeFile(path.join(projectPath, "package.json"), JSON.stringify(packageJson, null, 2));
}

/**
 * Generate the base template for a framework
 * @param framework - Framework name
 * @param config - Project configuration
 * @param projectPath - Project directory path
 * @param additionalDirs - Additional directories to copy
 */
export async function generateBaseTemplate(
  framework: string,
  config: ProjectConfig,
  projectPath: string,
  additionalDirs: { source: string; dest: string }[] = []
) {
  const templateRoot = getTemplateRoot();
  const templateEngine = createTemplateEngine(templateRoot);
  const pluginManager = getPluginManager();

  const isMonorepo = config.backend && config.backend !== "none" && config.backend !== "next-api";

  const context = {
    config,
    projectPath,
    templateEngine,
    logger: consola,
  };

  try {
    await pluginManager.runPreGenerate(context);

    if (isMonorepo) {
      await generateMonorepoProject(framework, config, projectPath, templateEngine);
    } else {
      await generateSingleAppProject(framework, config, projectPath, templateEngine);
    }

    for (const dir of additionalDirs) {
      await templateEngine.copyTemplateDirectory(
        dir.source,
        path.join(projectPath, dir.dest),
        config,
        { overwrite: true }
      );
    }

    await pluginManager.runGenerate(context);
    await pluginManager.runPostGenerate(context);

    logger.verbose(
      `${framework.charAt(0).toUpperCase() + framework.slice(1)} project generated successfully!`
    );
  } catch (error) {
    consola.error(`Failed to generate ${framework} project:`, error);
    throw error;
  }
}

/**
 * Generate a single application project structure
 * @param framework - Framework name
 * @param config - Project configuration
 * @param projectPath - Project directory path
 * @param templateEngine - Template engine instance
 */
async function generateSingleAppProject(
  framework: string,
  config: ProjectConfig,
  projectPath: string,
  templateEngine: any
) {
  await templateEngine.copyTemplateDirectory(`frameworks/${framework}/base`, projectPath, config, {
    overwrite: true,
  });

  // Copy common public assets first (for all frameworks)
  const commonPublicDir = `common/public`;
  const extendedConfig = {
    ...config,
    currentDate: new Date().toISOString().split("T")[0], // Add current date for sitemap
  };
  await templateEngine.copyTemplateDirectory(
    commonPublicDir,
    path.join(projectPath, "public"),
    extendedConfig,
    {
      overwrite: false, // Don't overwrite framework-specific files
    }
  );

  // Copy common src config (constants, etc.)
  const commonSrcDir = `common/src`;
  await templateEngine.copyTemplateDirectory(commonSrcDir, path.join(projectPath, "src"), config, {
    overwrite: false, // Don't overwrite framework-specific files
  });

  // Copy src directory if it exists (for all frameworks including TanStack Start)
  const srcDir = `frameworks/${framework}/src`;
  if (
    await templateEngine
      .getAvailableTemplates(`frameworks/${framework}`)
      .then((dirs: string[]) => dirs.includes("src"))
  ) {
    await templateEngine.copyTemplateDirectory(srcDir, path.join(projectPath, "src"), config, {
      overwrite: true,
    });
  }

  // Copy common components (PrecastBanner, etc.) AFTER framework src
  const commonComponentsDir = `common/components`;
  try {
    const componentsPath = path.join(projectPath, "src/components");

    await templateEngine.copyTemplateDirectory(commonComponentsDir, componentsPath, config, {
      overwrite: false, // Don't overwrite framework-specific components
    });
  } catch (error) {
    // Log but don't fail if common components don't exist
    consola.debug(`Common components not found or error copying: ${error}`);
  }

  const publicDir = `frameworks/${framework}/public`;
  if (
    await templateEngine
      .getAvailableTemplates(`frameworks/${framework}`)
      .then((dirs: string[]) => dirs.includes("public"))
  ) {
    await templateEngine.copyTemplateDirectory(
      publicDir,
      path.join(projectPath, "public"),
      config,
      {
        overwrite: true,
      }
    );
  }
}

/**
 * Generate a monorepo project structure with separate frontend and backend
 * @param framework - Frontend framework name
 * @param config - Project configuration
 * @param projectPath - Project directory path
 * @param templateEngine - Template engine instance
 */
async function generateMonorepoProject(
  framework: string,
  config: ProjectConfig,
  projectPath: string,
  templateEngine: any
) {
  logger.verbose("Generating monorepo structure...");

  await templateEngine.copyTemplateDirectory("workspace", projectPath, config, {
    overwrite: true,
  });

  const appsDir = path.join(projectPath, "apps");

  await fs.mkdir(appsDir, { recursive: true });

  const webDir = path.join(appsDir, "web");
  await fs.mkdir(webDir, { recursive: true });

  await templateEngine.copyTemplateDirectory(`frameworks/${framework}/base`, webDir, config, {
    overwrite: true,
  });

  // Copy common public assets first (for all frameworks)
  const commonPublicDir = `common/public`;
  const extendedConfig = {
    ...config,
    currentDate: new Date().toISOString().split("T")[0], // Add current date for sitemap
  };
  await templateEngine.copyTemplateDirectory(
    commonPublicDir,
    path.join(webDir, "public"),
    extendedConfig,
    {
      overwrite: false, // Don't overwrite framework-specific files
    }
  );

  // Handle TanStack Start's app directory structure
  if (framework === "tanstack-start") {
    const appDir = `frameworks/${framework}/app`;
    if (
      await templateEngine
        .getAvailableTemplates(`frameworks/${framework}`)
        .then((dirs: string[]) => dirs.includes("app"))
    ) {
      await templateEngine.copyTemplateDirectory(appDir, path.join(webDir, "app"), config, {
        overwrite: true,
      });
    }
  } else {
    const srcDir = `frameworks/${framework}/src`;
    if (
      await templateEngine
        .getAvailableTemplates(`frameworks/${framework}`)
        .then((dirs: string[]) => dirs.includes("src"))
    ) {
      await templateEngine.copyTemplateDirectory(srcDir, path.join(webDir, "src"), config, {
        overwrite: true,
      });
    }
  }

  // Copy common components (PrecastBanner, etc.) AFTER framework src/app
  const commonComponentsDir = `common/components`;
  try {
    const componentsPath =
      framework === "tanstack-start"
        ? path.join(webDir, "app/components")
        : path.join(webDir, "src/components");

    await templateEngine.copyTemplateDirectory(commonComponentsDir, componentsPath, config, {
      overwrite: false, // Don't overwrite framework-specific components
    });
  } catch (error) {
    // Log but don't fail if common components don't exist
    consola.debug(`Common components not found or error copying: ${error}`);
  }

  const publicDir = `frameworks/${framework}/public`;
  if (
    await templateEngine
      .getAvailableTemplates(`frameworks/${framework}`)
      .then((dirs: string[]) => dirs.includes("public"))
  ) {
    await templateEngine.copyTemplateDirectory(publicDir, path.join(webDir, "public"), config, {
      overwrite: true,
    });
  }

  if (config.backend && config.backend !== "none") {
    // Use "workers" folder for cloudflare-workers, "api" for everything else
    const backendFolderName = config.backend === "cloudflare-workers" ? "workers" : "api";
    const apiDir = path.join(appsDir, backendFolderName);
    await fs.mkdir(apiDir, { recursive: true });
    await generateBackendTemplate(config.backend, config, apiDir);
  }

  logger.verbose("Monorepo structure created successfully!");
}
