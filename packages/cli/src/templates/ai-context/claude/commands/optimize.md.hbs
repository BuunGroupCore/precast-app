---
description: Intelligent optimization orchestrator for performance, bundle size, and efficiency improvements
allowed-tools: Read, Write, Edit, Glob, Grep, Task, Bash, WebSearch, WebFetch
---

Performance optimization orchestrator that intelligently analyzes your {{framework}} project and coordinates multiple agents for comprehensive optimization.

## Optimization Orchestration

This command serves as an intelligent optimization dispatcher that:
1. **Analyzes performance bottlenecks** across your entire stack
2. **Researches latest optimization techniques** specific to your tech stack
3. **Coordinates multiple optimization agents** for comprehensive improvements
4. **Validates optimizations** don't break functionality
5. **Measures improvement impact** with before/after analysis

## Automatic Optimization Workflow

### Phase 1: Performance Analysis and Research
```
Use Task tool to spawn multiple agents simultaneously:

1. **web-research agent**:
   Research latest {{framework}} performance optimization techniques 2025:
   - Bundle size optimization strategies
   - Runtime performance improvements  
   - {{framework}} specific optimization patterns
   {{#if (eq styling "tailwind")}}
   - Tailwind CSS production optimizations
   {{/if}}
   {{#if backend}}
   - {{backend}} performance best practices
   {{/if}}

2. **architecture-guide agent**:
   Analyze current project architecture for optimization opportunities:
   - Component structure efficiency
   - State management performance
   - Code splitting opportunities
   - Asset optimization potential

3. **standards-enforcer agent**:
   Identify performance anti-patterns and violations:
   - Memory leaks and performance issues
   - Inefficient rendering patterns
   - Bundle size violations
```

### Phase 2: Targeted Optimization Implementation
```
Based on research and analysis findings, coordinate optimization implementation:

1. **refactor command**: Apply modern optimization patterns found in research
2. **monorepo/optimize command**: Optimize build pipeline and dependency management
3. **implement command**: Add performance monitoring and optimization tooling
```

### Phase 3: Validation and Measurement
```
1. **code-reviewer agent**: Validate optimization doesn't introduce issues
2. **Performance measurement**: Compare before/after metrics
3. **Documentation updates**: Record optimization decisions and measurements
```

## Optimization Categories

### Bundle Size Optimization
**Triggered by**: bundle, size, build, production, deploy
```
Example: "optimize bundle size for production"

Orchestration:
- Research tree-shaking and dead code elimination techniques
- Analyze current bundle composition
- Implement code splitting strategies
- Configure production build optimizations
- Measure bundle size improvements
```

### Runtime Performance Optimization  
**Triggered by**: performance, slow, fast, runtime, user experience
```
Example: "optimize app performance for better user experience"

Orchestration:
- Research {{framework}} performance patterns and Core Web Vitals
- Analyze component render performance
- Implement memoization and optimization hooks
- Add performance monitoring
- Validate improvements with metrics
```

### Development Performance
**Triggered by**: dev, development, build time, hot reload
```
Example: "optimize development build times"

Orchestration:
- Research fast development tooling and configurations
- Analyze current build pipeline bottlenecks
- Implement incremental builds and caching
- Optimize hot module replacement
- Measure development experience improvements
```

### Database/API Performance
**Triggered by**: database, api, query, request, response
```
Example: "optimize database queries and API performance"

Orchestration:
- Research {{database}} optimization techniques and {{orm}} best practices
- Analyze current query patterns and N+1 issues
- Implement caching strategies and query optimization
- Add API performance monitoring
- Validate query performance improvements
```

## Smart Context-Aware Optimization

### {{framework}} Specific Optimizations
{{#if (eq framework "react")}}
- React.memo and useMemo optimization
- Component lazy loading
- Suspense and concurrent features
- Bundle splitting strategies
{{else if (eq framework "vue")}}
- Async component optimization
- Computed property efficiency  
- Keep-alive caching
- Composition API performance
{{else if (eq framework "angular")}}
- OnPush change detection
- Lazy loading modules
- RxJS optimization
- AOT compilation benefits
{{else if (eq framework "next")}}
- Static generation optimization
- Image optimization
- API route performance
- Edge function utilization
{{/if}}

### Backend Optimization Context
{{#if backend}}
#### {{backend}} Performance Patterns
- Async/await optimization
- Middleware efficiency
- Caching strategies
- Database connection pooling
{{/if}}

### Database Optimization Focus
{{#if database}}
#### {{database}} with {{orm}} Optimization
- Query optimization and indexing
- Connection pooling
- Batch operations
- Caching strategies
{{/if}}

## Intelligent Optimization Routing

### Comprehensive Performance Audit
```
/optimize performance across the entire application

→ Full-stack performance analysis:
1. Frontend rendering optimization
2. Bundle size and loading optimization  
3. API response time optimization
4. Database query optimization
5. Development workflow optimization
```

### Specific Domain Optimization
```
/optimize React component rendering performance

→ Frontend-focused optimization:
1. Research React performance best practices
2. Analyze component render patterns
3. Implement memoization strategies
4. Add performance monitoring
```

### Production Deployment Optimization
```
/optimize for production deployment and user experience

→ Production-ready optimization:
1. Bundle size optimization
2. Asset optimization (images, fonts)
3. Caching strategies
4. Performance monitoring setup
```

## Optimization Measurement

### Performance Metrics Tracking
The orchestrator automatically includes measurement:
- **Bundle size** before/after analysis
- **Build time** improvements  
- **Runtime performance** metrics
- **Core Web Vitals** improvements
- **Development experience** enhancements

### Optimization Validation
Every optimization includes:
- **Functionality testing** to ensure no regressions
- **Performance benchmarking** to measure improvements
- **Code quality validation** to maintain standards
- **Documentation updates** to record decisions

## Advanced Optimization Patterns

### Progressive Optimization
```
1. **Low-hanging fruit**: Quick wins with high impact
2. **Structural improvements**: Architecture-level optimizations  
3. **Advanced techniques**: Cutting-edge optimization strategies
4. **Monitoring setup**: Long-term performance tracking
```

### Risk-Managed Optimization
```
1. **Non-breaking optimizations first**: Safe improvements
2. **Incremental changes**: Step-by-step optimization
3. **Rollback planning**: Safety nets for aggressive optimizations
4. **A/B testing setup**: Performance comparison strategies
```

## Optimization Examples

### Frontend Performance
```
/optimize my React app's loading performance and bundle size

→ Comprehensive frontend optimization:
- Code splitting and lazy loading
- Image and asset optimization
- CSS and styling optimization
- JavaScript bundle optimization
- Runtime performance improvements
```

### Full-Stack Performance  
```
/optimize database queries and API response times

→ Backend optimization focus:
- Database query analysis and optimization
- API endpoint performance improvements
- Caching strategy implementation
- Connection pooling optimization
```

### Development Workflow
```
/optimize development build times and hot reload speed

→ Developer experience optimization:
- Build pipeline optimization
- Hot module replacement improvements
- Development server configuration
- Tool and dependency optimization
```

Remember: The optimize command intelligently routes your optimization requests to the most appropriate agents and applies evidence-based performance improvements specific to your {{framework}} stack.