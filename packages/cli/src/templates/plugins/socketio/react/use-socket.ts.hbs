/**
 * Socket.io React Hooks
 * @module use-socket
 * @description Collection of React hooks for Socket.io integration
 */

import { useEffect, useCallback, useRef } from 'react';
import { useSocketContext } from '../providers/SocketProvider';

/**
 * Main hook for Socket.io operations in React components
 * @returns {Object} Socket utilities and connection state
 */
export const useSocket = () => {
  const { socket, isConnected } = useSocketContext();

  /**
   * Emits an event to the server
   * @param {string} event - Event name
   * @param {any} data - Data to send
   */
  const emit = useCallback((event: string, data?: any) => {
    if (socket && isConnected) {
      socket.emit(event, data);
    } else {
      console.warn('Socket not connected. Cannot emit event:', event);
    }
  }, [socket, isConnected]);

  /**
   * Listens to an event from the server
   * @param {string} event - Event name
   * @param {Function} handler - Event handler function
   * @returns {Function} Cleanup function to remove listener
   */
  const on = useCallback((event: string, handler: (...args: any[]) => void) => {
    if (socket) {
      socket.on(event, handler);
      
      return () => {
        socket.off(event, handler);
      };
    }
    return () => {};
  }, [socket]);

  /**
   * Listens to an event once
   * @param {string} event - Event name
   * @param {Function} handler - Event handler function
   */
  const once = useCallback((event: string, handler: (...args: any[]) => void) => {
    if (socket) {
      socket.once(event, handler);
    }
  }, [socket]);

  /**
   * Removes event listener
   * @param {string} event - Event name
   * @param {Function} handler - Optional specific handler to remove
   */
  const off = useCallback((event: string, handler?: (...args: any[]) => void) => {
    if (socket) {
      if (handler) {
        socket.off(event, handler);
      } else {
        socket.off(event);
      }
    }
  }, [socket]);

  return {
    socket,
    isConnected,
    emit,
    on,
    once,
    off,
  };
};

/**
 * Hook for listening to socket events with automatic cleanup
 * @param {string} event - Event name to listen to
 * @param {Function} handler - Event handler function
 * @param {any[]} deps - Dependency array for effect
 */
export const useSocketEvent = (event: string, handler: (...args: any[]) => void, deps: any[] = []) => {
  const { socket } = useSocketContext();
  const handlerRef = useRef(handler);

  useEffect(() => {
    handlerRef.current = handler;
  }, [handler]);

  useEffect(() => {
    if (!socket) return;

    const wrappedHandler = (...args: any[]) => {
      handlerRef.current(...args);
    };

    socket.on(event, wrappedHandler);

    return () => {
      socket.off(event, wrappedHandler);
    };
  }, [socket, event, ...deps]);
};

/**
 * Hook for managing socket room membership
 * @param {string} roomName - Name of the room to join/leave
 * @returns {Object} Room management functions
 */
export const useSocketRoom = (roomName: string) => {
  const { emit } = useSocket();

  const joinRoom = useCallback(() => {
    emit('join-room', { room: roomName });
  }, [emit, roomName]);

  const leaveRoom = useCallback(() => {
    emit('leave-room', { room: roomName });
  }, [emit, roomName]);

  useEffect(() => {
    if (roomName) {
      joinRoom();
    }

    return () => {
      if (roomName) {
        leaveRoom();
      }
    };
  }, [roomName, joinRoom, leaveRoom]);

  return { joinRoom, leaveRoom };
};

/**
 * Hook for real-time chat functionality
 * @param {string} roomId - Optional room ID for scoped chat
 * @returns {Object} Chat utilities and event handlers
 */
export const useChat = (roomId?: string) => {
  const { emit, on, off } = useSocket();

  const sendMessage = useCallback((message: string, metadata?: any) => {
    const messageData = {
      message,
      room: roomId,
      timestamp: new Date().toISOString(),
      ...metadata,
    };
    emit('send-message', messageData);
  }, [emit, roomId]);

  const onMessage = useCallback((handler: (data: any) => void) => {
    const cleanup = on('receive-message', handler);
    return cleanup;
  }, [on]);

  const onTyping = useCallback((handler: (data: any) => void) => {
    const cleanup = on('user-typing', handler);
    return cleanup;
  }, [on]);

  const sendTyping = useCallback((isTyping: boolean) => {
    emit('typing', { room: roomId, isTyping });
  }, [emit, roomId]);

  return {
    sendMessage,
    onMessage,
    onTyping,
    sendTyping,
  };
};

/**
 * Hook for real-time notifications
 * @returns {Object} Notification event handlers
 */
export const useNotifications = () => {
  const { on } = useSocket();

  const onNotification = useCallback((handler: (notification: any) => void) => {
    const cleanup = on('notification', handler);
    return cleanup;
  }, [on]);

  return { onNotification };
};