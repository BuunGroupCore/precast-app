/**
 * useGenericTesting Hook
 * @module useGenericTesting
 * @description Hook for managing test results and loading states across service tests
 */

import { useState, useCallback } from 'react';
import { TestResult, LoadingState, TestResultsState } from '../types';

/**
 * Hook for managing test results and loading states
 * @returns {Object} Test management utilities and state
 */
export function useGenericTesting() {
  const [testResults, setTestResults] = useState<TestResultsState>({});
  const [loading, setLoading] = useState<LoadingState>({});

  /**
   * Adds a test result for a specific service
   * @param {string} service - Service name
   * @param {Omit<TestResult, "timestamp">} result - Test result without timestamp
   */
  const addTestResult = useCallback((service: string, result: Omit<TestResult, "timestamp">) => {
    setTestResults((prev) => ({
      ...prev,
      [service]: {
        ...result,
        timestamp: new Date().toISOString(),
      },
    }));
  }, []);

  /**
   * Set loading state for a specific service
   * @param {string} service - Service name
   * @param {boolean} isLoading - Loading state
   */
  const setServiceLoading = useCallback((service: string, isLoading: boolean) => {
    setLoading((prev) => ({ ...prev, [service]: isLoading }));
  }, []);

  /**
   * Get test result for a specific service
   * @param {string} service - Service name
   * @returns {TestResult | null} Test result or null if not found
   */
  const getTestResult = useCallback((service: string): TestResult | null => {
    return testResults[service] || null;
  }, [testResults]);

  /**
   * Check if a service is currently loading
   * @param {string} service - Service name
   * @returns {boolean} True if service is loading
   */
  const isServiceLoading = useCallback((service: string): boolean => {
    return loading[service] || false;
  }, [loading]);

  /**
   * Clear test result for a specific service
   * @param {string} service - Service name
   */
  const clearTestResult = useCallback((service: string) => {
    setTestResults((prev) => {
      const newResults = { ...prev };
      delete newResults[service];
      return newResults;
    });
  }, []);

  /**
   * Clear all test results
   */
  const clearAllTestResults = useCallback(() => {
    setTestResults({});
  }, []);

  /**
   * Get all test results as array
   * @returns {Array<{service: string} & TestResult>} Array of test results with service names
   */
  const getAllTestResults = useCallback(() => {
    return Object.entries(testResults).map(([service, result]) => ({
      service,
      ...result,
    }));
  }, [testResults]);

  /**
   * Get count of successful tests
   * @returns {number} Number of successful tests
   */
  const getSuccessfulTestCount = useCallback(() => {
    return Object.values(testResults).filter(result => result.success).length;
  }, [testResults]);

  /**
   * Get count of failed tests
   * @returns {number} Number of failed tests
   */
  const getFailedTestCount = useCallback(() => {
    return Object.values(testResults).filter(result => !result.success).length;
  }, [testResults]);

  /**
   * Get overall test status
   * @returns {'no-tests' | 'has-failures' | 'all-passing'} Overall test status
   */
  const getOverallStatus = useCallback(() => {
    const results = Object.values(testResults);
    if (results.length === 0) return 'no-tests';
    
    const hasFailures = results.some(result => !result.success);
    return hasFailures ? 'has-failures' : 'all-passing';
  }, [testResults]);

  /**
   * Check if any tests are currently running
   * @returns {boolean} True if any tests are running
   */
  const hasActiveTests = useCallback(() => {
    return Object.values(loading).some(isLoading => isLoading);
  }, [loading]);

  /**
   * Generic test runner function
   * @param {string} serviceName - Name of the service being tested
   * @param {() => Promise<void>} testFunction - Test function to execute
   */
  const runTest = useCallback(async (
    serviceName: string,
    testFunction: () => Promise<void>
  ) => {
    setServiceLoading(serviceName, true);
    try {
      await testFunction();
    } catch (error) {
      addTestResult(serviceName, {
        success: false,
        message: `${serviceName.toUpperCase()} TEST FAILED`,
        details: error instanceof Error ? error.message : "Unknown error",
      });
    } finally {
      setServiceLoading(serviceName, false);
    }
  }, [addTestResult, setServiceLoading]);

  return {
    // State
    testResults,
    loading,
    
    // Actions
    addTestResult,
    setServiceLoading,
    clearTestResult,
    clearAllTestResults,
    runTest,
    
    // Getters
    getTestResult,
    isServiceLoading,
    getAllTestResults,
    getSuccessfulTestCount,
    getFailedTestCount,
    getOverallStatus,
    hasActiveTests,
    
    // Direct state setters for compatibility with existing code
    setLoading,
    setTestResults,
  };
}