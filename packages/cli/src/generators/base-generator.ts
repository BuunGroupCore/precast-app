import fs from "fs/promises";
import path from "path";

import { type ProjectConfig } from "@shared/stack-config.js";
import { consola } from "consola";

import { getPluginManager } from "@/core/plugin-manager.js";
import { createTemplateEngine } from "@/core/template-engine.js";
import { generateBackendTemplate } from "@/generators/features/backend-generator.js";
import { getTemplateRoot } from "@/utils/system/template-path.js";
import { logger } from "@/utils/ui/logger.js";

/**
 * Map framework names to their template directory structure.
 * Handles the reorganized template structure with ecosystem-based organization.
 *
 * @param framework - Framework identifier
 * @returns Path to the framework's template directory
 */
function getFrameworkPath(framework: string): string {
  const frameworkMap: Record<string, string> = {
    react: "react/bare",
    "react-router": "react/router-v7",
    "react-native": "react/native",
    next: "react/next",
    "tanstack-router": "react/tanstack-router",
    "tanstack-start": "react/tanstack-start",
    "vite-react": "react/vite",

    vue: "vue",
    nuxt: "vue/nuxt",
    "vite-vue": "vue/vite",

    svelte: "svelte",
    "vite-svelte": "svelte/vite",

    solid: "solid/bare",
    "vite-solid": "solid/vite",

    vanilla: "vanilla/bare",
    "vite-vanilla": "vanilla/vite",

    angular: "angular",
    astro: "astro",
    vite: "vite",
  };

  return frameworkMap[framework] || framework;
}

/**
 * Generate package.json file for a project with framework-specific configuration.
 * Creates a complete package.json with dependencies, scripts, and metadata.
 *
 * @param config - Complete project configuration
 * @param projectPath - Absolute path to the project directory
 * @param dependencies - Array of runtime dependency names
 * @param devDependencies - Array of development dependency names
 * @param additionalFields - Extra fields to merge into package.json
 */
export async function generatePackageJson(
  config: ProjectConfig,
  projectPath: string,
  dependencies: string[] = [],
  devDependencies: string[] = [],
  additionalFields: Record<string, any> = {}
): Promise<void> {
  const packageJson = {
    name: config.name,
    version: "0.1.0",
    private: true,
    description: `${config.framework} application generated by create-precast-app`,
    ...additionalFields,
    dependencies: dependencies.reduce(
      (acc, dep) => {
        acc[dep] = "latest";
        return acc;
      },
      {} as Record<string, string>
    ),
    devDependencies: devDependencies.reduce(
      (acc, dep) => {
        acc[dep] = "latest";
        return acc;
      },
      {} as Record<string, string>
    ),
  };

  await fs.writeFile(path.join(projectPath, "package.json"), JSON.stringify(packageJson, null, 2));
}

/**
 * Generate the base template for a framework with support for monorepo and single-app structures.
 * Handles template copying, plugin management, and project structure generation.
 *
 * @param framework - Framework identifier (react, vue, next, etc.)
 * @param config - Complete project configuration
 * @param projectPath - Absolute path to the project directory
 * @param additionalDirs - Additional template directories to copy with custom paths
 */
export async function generateBaseTemplate(
  framework: string,
  config: ProjectConfig,
  projectPath: string,
  additionalDirs: { source: string; dest: string }[] = []
) {
  const templateRoot = getTemplateRoot();
  const templateEngine = createTemplateEngine(templateRoot);
  const pluginManager = getPluginManager();

  const isMonorepo = config.backend && config.backend !== "none" && config.backend !== "next-api";

  const context = {
    config,
    projectPath,
    templateEngine,
    logger: consola,
  };

  try {
    await pluginManager.runPreGenerate(context);

    if (isMonorepo) {
      await generateMonorepoProject(framework, config, projectPath, templateEngine);
    } else {
      await generateSingleAppProject(framework, config, projectPath, templateEngine);
    }

    for (const dir of additionalDirs) {
      await templateEngine.copyTemplateDirectory(
        dir.source,
        path.join(projectPath, dir.dest),
        config,
        { overwrite: true }
      );
    }

    await pluginManager.runGenerate(context);
    await pluginManager.runPostGenerate(context);

    logger.verbose(
      `${framework.charAt(0).toUpperCase() + framework.slice(1)} project generated successfully!`
    );
  } catch (error) {
    consola.error(`Failed to generate ${framework} project:`, error);
    throw error;
  }
}

/**
 * Generate a single application project structure (non-monorepo).
 * Copies framework templates, common assets, styles, and pages.
 *
 * @param framework - Framework identifier
 * @param config - Project configuration
 * @param projectPath - Absolute path to the project directory
 * @param templateEngine - Template engine instance for processing files
 */
async function generateSingleAppProject(
  framework: string,
  config: ProjectConfig,
  projectPath: string,
  templateEngine: any
) {
  const frameworkPath = getFrameworkPath(framework);
  await templateEngine.copyTemplateDirectory(
    `frameworks/${frameworkPath}/base`,
    projectPath,
    config,
    {
      overwrite: true,
    }
  );

  const commonPublicDir = `common/public`;
  const extendedConfig = {
    ...config,
    currentDate: new Date().toISOString().split("T")[0],
  };
  await templateEngine.copyTemplateDirectory(
    commonPublicDir,
    path.join(projectPath, "public"),
    extendedConfig,
    {
      overwrite: false,
    }
  );

  if (framework !== "svelte") {
    const commonStylesDir = `common/styles`;
    try {
      const stylesPath = path.join(projectPath, "src/styles");

      const globalsPath = path.join(stylesPath, "globals.css");
      const hasGlobals = await fs
        .access(globalsPath)
        .then(() => true)
        .catch(() => false);

      if (!hasGlobals) {
        await templateEngine.copyTemplateDirectory(commonStylesDir, stylesPath, config, {
          overwrite: false,
        });
      } else {
        consola.debug("Skipping common styles - globals.css already exists");
      }
    } catch (error) {
      consola.debug(`Common styles not found or error copying: ${error}`);
    }
  }

  // Handle pages differently for Next.js (app directory) vs other frameworks
  const commonPagesDir = `common/pages`;
  try {
    if (framework === "next") {
      // For Next.js, copy page content into app directory structure
      // Copy home page content to app directory
      const _homePagesDir = `${commonPagesDir}/home`;
      const _notFoundPagesDir = `${commonPagesDir}/not-found`;

      // Home page content should be merged with app/page.tsx
      // Not-found page content should go to app/not-found.tsx

      // For now, we'll copy the components that the pages use
      // The actual page content is already in the Next.js app/page.tsx template
      consola.debug("Next.js uses app directory - page components will be available");
    } else {
      // For other frameworks, copy pages as usual
      await templateEngine.copyTemplateDirectory(
        commonPagesDir,
        path.join(projectPath, "src/pages"),
        config,
        {
          overwrite: true,
        }
      );
    }
  } catch (error) {
    consola.debug(`Common pages not found or error copying: ${error}`);
  }

  const srcDir = `frameworks/${frameworkPath}/src`;
  if (
    await templateEngine
      .getAvailableTemplates(`frameworks/${frameworkPath}`)
      .then((dirs: string[]) => dirs.includes("src"))
  ) {
    await templateEngine.copyTemplateDirectory(srcDir, path.join(projectPath, "src"), config, {
      overwrite: true,
    });
  }

  const reactFrameworks = ["react", "next", "react-router", "tanstack-router", "tanstack-start"];
  if (reactFrameworks.includes(framework)) {
    const commonComponentsDir = `common/components`;
    try {
      const componentsPath = path.join(projectPath, "src/components");

      const indexPath = path.join(componentsPath, "index.ts");
      const indexPathJs = path.join(componentsPath, "index.js");
      const hasIndex =
        (await fs
          .access(indexPath)
          .then(() => true)
          .catch(() => false)) ||
        (await fs
          .access(indexPathJs)
          .then(() => true)
          .catch(() => false));

      if (!hasIndex) {
        await templateEngine.copyTemplateDirectory(commonComponentsDir, componentsPath, config, {
          overwrite: false,
        });
      } else {
        consola.debug("Skipping common components - index already exists");
      }
    } catch (error) {
      consola.debug(`Common components not found or error copying: ${error}`);
    }
  }

  const commonConfigDir = `common/config`;
  try {
    const configPath = path.join(projectPath, "src/config");

    const constantsPath = path.join(configPath, "constants.ts");
    const constantsPathJs = path.join(configPath, "constants.js");
    const hasConstants =
      (await fs
        .access(constantsPath)
        .then(() => true)
        .catch(() => false)) ||
      (await fs
        .access(constantsPathJs)
        .then(() => true)
        .catch(() => false));

    if (!hasConstants) {
      await templateEngine.copyTemplateDirectory(commonConfigDir, configPath, config, {
        overwrite: false,
      });
    } else {
      consola.debug("Skipping common config - constants already exist");
    }
  } catch (error) {
    consola.debug(`Common config not found or error copying: ${error}`);
  }

  if (framework !== "next" && framework !== "nuxt") {
    try {
      await templateEngine.copyTemplate(
        "common/vite-env.d.ts.hbs",
        path.join(projectPath, "src/vite-env.d.ts"),
        config
      );
    } catch (error) {
      consola.debug(`vite-env.d.ts not found or error copying: ${error}`);
    }
  }

  const publicDir = `frameworks/${frameworkPath}/public`;
  if (
    await templateEngine
      .getAvailableTemplates(`frameworks/${frameworkPath}`)
      .then((dirs: string[]) => dirs.includes("public"))
  ) {
    await templateEngine.copyTemplateDirectory(
      publicDir,
      path.join(projectPath, "public"),
      config,
      {
        overwrite: true,
      }
    );
  }
}

/**
 * Generate a monorepo project structure with separate frontend and backend applications.
 * Creates a multi-package workspace with shared dependencies and configuration.
 *
 * @param framework - Frontend framework identifier
 * @param config - Complete project configuration
 * @param projectPath - Absolute path to the project directory
 * @param templateEngine - Template engine instance for processing files
 */
async function generateMonorepoProject(
  framework: string,
  config: ProjectConfig,
  projectPath: string,
  templateEngine: any
) {
  logger.verbose("Generating monorepo structure...");

  const frameworkPath = getFrameworkPath(framework);

  await templateEngine.copyTemplateDirectory("workspace", projectPath, config, {
    overwrite: true,
  });

  const appsDir = path.join(projectPath, "apps");

  await fs.mkdir(appsDir, { recursive: true });

  const webDir = path.join(appsDir, "web");
  await fs.mkdir(webDir, { recursive: true });

  await templateEngine.copyTemplateDirectory(`frameworks/${frameworkPath}/base`, webDir, config, {
    overwrite: true,
  });

  const commonPublicDir = `common/public`;
  const extendedConfig = {
    ...config,
    currentDate: new Date().toISOString().split("T")[0],
  };
  await templateEngine.copyTemplateDirectory(
    commonPublicDir,
    path.join(webDir, "public"),
    extendedConfig,
    {
      overwrite: false,
    }
  );

  const srcDir = `frameworks/${frameworkPath}/src`;
  if (
    await templateEngine
      .getAvailableTemplates(`frameworks/${frameworkPath}`)
      .then((dirs: string[]) => dirs.includes("src"))
  ) {
    await templateEngine.copyTemplateDirectory(srcDir, path.join(webDir, "src"), config, {
      overwrite: true,
    });
  }

  if (framework !== "svelte") {
    const commonStylesDir = `common/styles`;
    try {
      const stylesPath = path.join(webDir, "src/styles");

      const globalsPath = path.join(stylesPath, "globals.css");
      const hasGlobals = await fs
        .access(globalsPath)
        .then(() => true)
        .catch(() => false);

      if (!hasGlobals) {
        await templateEngine.copyTemplateDirectory(commonStylesDir, stylesPath, config, {
          overwrite: false,
        });
      }
    } catch (error) {
      consola.debug(`Common styles not found or error copying: ${error}`);
    }
  }

  // For Next.js, skip copying common pages since they use app directory
  // For other frameworks, copy pages as usual
  if (framework !== "next") {
    const commonPagesDir = `common/pages`;
    try {
      const pagesPath = path.join(webDir, "src/pages");

      await templateEngine.copyTemplateDirectory(commonPagesDir, pagesPath, config, {
        overwrite: true,
      });
    } catch (error) {
      consola.debug(`Common pages not found or error copying: ${error}`);
    }
  }

  const reactFrameworks = ["react", "next", "react-router", "tanstack-router", "tanstack-start"];
  if (reactFrameworks.includes(framework)) {
    const commonComponentsDir = `common/components`;
    try {
      const componentsPath = path.join(webDir, "src/components");

      const indexPath = path.join(componentsPath, "index.ts");
      const indexPathJs = path.join(componentsPath, "index.js");
      const hasIndex =
        (await fs
          .access(indexPath)
          .then(() => true)
          .catch(() => false)) ||
        (await fs
          .access(indexPathJs)
          .then(() => true)
          .catch(() => false));

      if (!hasIndex) {
        await templateEngine.copyTemplateDirectory(commonComponentsDir, componentsPath, config, {
          overwrite: false,
        });
      }
    } catch (error) {
      consola.debug(`Common components not found or error copying: ${error}`);
    }
  }

  const commonConfigDir = `common/config`;
  try {
    const configPath = path.join(webDir, "src/config");

    const constantsPath = path.join(configPath, "constants.ts");
    const constantsPathJs = path.join(configPath, "constants.js");
    const hasConstants =
      (await fs
        .access(constantsPath)
        .then(() => true)
        .catch(() => false)) ||
      (await fs
        .access(constantsPathJs)
        .then(() => true)
        .catch(() => false));

    if (!hasConstants) {
      await templateEngine.copyTemplateDirectory(commonConfigDir, configPath, config, {
        overwrite: false,
      });
    }
  } catch (error) {
    consola.debug(`Common config not found or error copying: ${error}`);
  }

  if (framework !== "next" && framework !== "nuxt") {
    try {
      const viteEnvPath = path.join(webDir, "src/vite-env.d.ts");
      await templateEngine.copyTemplate("common/vite-env.d.ts.hbs", viteEnvPath, config);
    } catch (error) {
      consola.debug(`vite-env.d.ts not found or error copying: ${error}`);
    }
  }

  const publicDir = `frameworks/${frameworkPath}/public`;
  if (
    await templateEngine
      .getAvailableTemplates(`frameworks/${frameworkPath}`)
      .then((dirs: string[]) => dirs.includes("public"))
  ) {
    await templateEngine.copyTemplateDirectory(publicDir, path.join(webDir, "public"), config, {
      overwrite: true,
    });
  }

  if (config.backend && config.backend !== "none") {
    const backendFolderName = config.backend === "cloudflare-workers" ? "workers" : "api";
    const apiDir = path.join(appsDir, backendFolderName);
    await fs.mkdir(apiDir, { recursive: true });
    await generateBackendTemplate(config.backend, config, apiDir);

    const packagesDir = path.join(projectPath, "packages");
    const sharedDir = path.join(packagesDir, "shared");
    await fs.mkdir(packagesDir, { recursive: true });
    await fs.mkdir(sharedDir, { recursive: true });

    await templateEngine.copyTemplateDirectory("packages/shared", sharedDir, config, {
      overwrite: true,
    });

    const webPackageJsonPath = path.join(webDir, "package.json");
    const apiPackageJsonPath = path.join(apiDir, "package.json");
    const sharedPackageName = `@${config.name}/shared`;

    if (
      await fs
        .access(webPackageJsonPath)
        .then(() => true)
        .catch(() => false)
    ) {
      const webPackageJson = JSON.parse(await fs.readFile(webPackageJsonPath, "utf-8"));
      webPackageJson.dependencies = webPackageJson.dependencies || {};
      webPackageJson.dependencies[sharedPackageName] = "workspace:*";
      await fs.writeFile(webPackageJsonPath, JSON.stringify(webPackageJson, null, 2));
    }

    if (
      await fs
        .access(apiPackageJsonPath)
        .then(() => true)
        .catch(() => false)
    ) {
      const apiPackageJson = JSON.parse(await fs.readFile(apiPackageJsonPath, "utf-8"));
      apiPackageJson.dependencies = apiPackageJson.dependencies || {};
      apiPackageJson.dependencies[sharedPackageName] = "workspace:*";
      await fs.writeFile(apiPackageJsonPath, JSON.stringify(apiPackageJson, null, 2));
    }

    logger.verbose("Created packages/shared for type sharing between apps");
  }

  logger.verbose("Monorepo structure created successfully!");
}
