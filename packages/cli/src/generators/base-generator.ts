import fs from "fs/promises";
import path from "path";

import { consola } from "consola";

import { type ProjectConfig } from "../../../shared/stack-config.js";
import { getPluginManager } from "../core/plugin-manager.js";
import { createTemplateEngine } from "../core/template-engine.js";
import { getTemplateRoot } from "../utils/template-path.js";

import { generateBackendTemplate } from "./backend-generator.js";

/**
 * Generate package.json file for a project
 * @param config - Project configuration
 * @param projectPath - Project directory path
 * @param dependencies - Runtime dependencies
 * @param devDependencies - Development dependencies
 * @param additionalFields - Additional package.json fields
 */
export async function generatePackageJson(
  config: ProjectConfig,
  projectPath: string,
  dependencies: string[] = [],
  devDependencies: string[] = [],
  additionalFields: Record<string, any> = {}
): Promise<void> {
  const packageJson = {
    name: config.name,
    version: "0.1.0",
    private: true,
    description: `${config.framework} application generated by create-precast-app`,
    ...additionalFields,
    dependencies: dependencies.reduce(
      (acc, dep) => {
        acc[dep] = "latest";
        return acc;
      },
      {} as Record<string, string>
    ),
    devDependencies: devDependencies.reduce(
      (acc, dep) => {
        acc[dep] = "latest";
        return acc;
      },
      {} as Record<string, string>
    ),
  };

  await fs.writeFile(path.join(projectPath, "package.json"), JSON.stringify(packageJson, null, 2));
}

/**
 * Generate the base template for a framework
 * @param framework - Framework name
 * @param config - Project configuration
 * @param projectPath - Project directory path
 * @param additionalDirs - Additional directories to copy
 */
export async function generateBaseTemplate(
  framework: string,
  config: ProjectConfig,
  projectPath: string,
  additionalDirs: { source: string; dest: string }[] = []
) {
  const templateRoot = getTemplateRoot();
  const templateEngine = createTemplateEngine(templateRoot);
  const pluginManager = getPluginManager();

  const isMonorepo = config.backend && config.backend !== "none" && config.backend !== "next-api";

  const context = {
    config,
    projectPath,
    templateEngine,
    logger: consola,
  };

  try {
    await pluginManager.runPreGenerate(context);

    if (isMonorepo) {
      await generateMonorepoProject(framework, config, projectPath, templateEngine);
    } else {
      await generateSingleAppProject(framework, config, projectPath, templateEngine);
    }

    for (const dir of additionalDirs) {
      await templateEngine.copyTemplateDirectory(
        dir.source,
        path.join(projectPath, dir.dest),
        config,
        { overwrite: true }
      );
    }

    await pluginManager.runGenerate(context);
    await pluginManager.runPostGenerate(context);

    consola.success(
      `${framework.charAt(0).toUpperCase() + framework.slice(1)} project generated successfully!`
    );
  } catch (error) {
    consola.error(`Failed to generate ${framework} project:`, error);
    throw error;
  }
}

/**
 * Generate a single application project structure
 * @param framework - Framework name
 * @param config - Project configuration
 * @param projectPath - Project directory path
 * @param templateEngine - Template engine instance
 */
async function generateSingleAppProject(
  framework: string,
  config: ProjectConfig,
  projectPath: string,
  templateEngine: any
) {
  await templateEngine.copyTemplateDirectory(`frameworks/${framework}/base`, projectPath, config, {
    overwrite: true,
  });

  const srcDir = `frameworks/${framework}/src`;
  if (
    await templateEngine
      .getAvailableTemplates(`frameworks/${framework}`)
      .then((dirs: string[]) => dirs.includes("src"))
  ) {
    await templateEngine.copyTemplateDirectory(srcDir, path.join(projectPath, "src"), config, {
      overwrite: true,
    });
  }
}

/**
 * Generate a monorepo project structure with separate frontend and backend
 * @param framework - Frontend framework name
 * @param config - Project configuration
 * @param projectPath - Project directory path
 * @param templateEngine - Template engine instance
 */
async function generateMonorepoProject(
  framework: string,
  config: ProjectConfig,
  projectPath: string,
  templateEngine: any
) {
  consola.info("Generating monorepo structure...");

  await templateEngine.copyTemplateDirectory("workspace", projectPath, config, {
    overwrite: true,
  });

  const appsDir = path.join(projectPath, "apps");
  const packagesDir = path.join(projectPath, "packages");

  await fs.mkdir(appsDir, { recursive: true });
  await fs.mkdir(packagesDir, { recursive: true });

  const webDir = path.join(appsDir, "web");
  await fs.mkdir(webDir, { recursive: true });

  await templateEngine.copyTemplateDirectory(`frameworks/${framework}/base`, webDir, config, {
    overwrite: true,
  });

  const srcDir = `frameworks/${framework}/src`;
  if (
    await templateEngine
      .getAvailableTemplates(`frameworks/${framework}`)
      .then((dirs: string[]) => dirs.includes("src"))
  ) {
    await templateEngine.copyTemplateDirectory(srcDir, path.join(webDir, "src"), config, {
      overwrite: true,
    });
  }

  if (config.backend && config.backend !== "none") {
    const apiDir = path.join(appsDir, "api");
    await fs.mkdir(apiDir, { recursive: true });
    await generateBackendTemplate(config.backend, config, apiDir);
  }

  const sharedDir = path.join(packagesDir, "shared");
  await fs.mkdir(sharedDir, { recursive: true });
  await templateEngine.copyTemplateDirectory("shared", sharedDir, config, {
    overwrite: true,
  });

  const sharedSrcExists = await templateEngine
    .getAvailableTemplates("shared")
    .then((dirs: string[]) => dirs.includes("src"))
    .catch(() => false);

  if (sharedSrcExists) {
    await templateEngine.copyTemplateDirectory("shared/src", path.join(sharedDir, "src"), config, {
      overwrite: true,
    });
  }

  consola.success("Monorepo structure created successfully!");
}
