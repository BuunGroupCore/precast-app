import { Auth } from "@auth/core";
import type { AuthConfig } from "@auth/core";
import Credentials from "@auth/core/providers/credentials";
import GitHub from "@auth/core/providers/github";
import Google from "@auth/core/providers/google";
{{#if (and orm (ne orm "none"))}}
{{#if (eq orm "prisma")}}
import { PrismaAdapter } from "@auth/prisma-adapter";
import { prisma } from "@/lib/prisma";
{{else if (eq orm "drizzle")}}
import { DrizzleAdapter } from "@auth/drizzle-adapter";
import { db } from "@/db";
import { users } from "@/db/schema";
import { eq } from "drizzle-orm";
{{/if}}
import bcrypt from "bcryptjs";
{{else if (and database (ne database "none"))}}
{{#if (eq database "postgres")}}
import PostgresAdapter from "@auth/pg-adapter";
import { Pool } from "pg";
{{else if (eq database "mysql")}}
import { MySQLAdapter } from "@auth/mysql-adapter";
import mysql from "mysql2/promise";
{{else if (eq database "mongodb")}}
import { MongoDBAdapter } from "@auth/mongodb-adapter";
import clientPromise from "@/lib/mongodb";
{{/if}}
import bcrypt from "bcryptjs";
{{/if}}

{{#if (and (ne orm "prisma") (ne orm "drizzle"))}}
{{#if (eq database "postgres")}}
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});
{{else if (eq database "mysql")}}
const pool = mysql.createPool({
  uri: process.env.DATABASE_URL,
});
{{else if (eq database "mongodb")}}
// MongoDB client is imported from lib/mongodb
{{/if}}
{{/if}}

export const authConfig: AuthConfig = {
  {{#if (and orm (ne orm "none"))}}
  {{#if (eq orm "prisma")}}
  adapter: PrismaAdapter(prisma),
  {{else if (eq orm "drizzle")}}
  adapter: DrizzleAdapter(db),
  {{/if}}
  {{else if (and database (ne database "none"))}}
  {{#if (eq database "postgres")}}
  adapter: PostgresAdapter(pool),
  {{else if (eq database "mysql")}}
  adapter: MySQLAdapter(pool),
  {{else if (eq database "mongodb")}}
  adapter: MongoDBAdapter(clientPromise),
  {{/if}}
  {{/if}}
  providers: [
    Credentials({
      name: "credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          return null;
        }

        {{#if (eq orm "prisma")}}
        const user = await prisma.user.findUnique({
          where: { email: credentials.email as string },
        });

        if (!user || !user.password) {
          return null;
        }

        const isPasswordValid = await bcrypt.compare(
          credentials.password as string,
          user.password
        );

        if (!isPasswordValid) {
          return null;
        }

        return {
          id: user.id,
          email: user.email,
          name: user.name,
        };
        {{else if (eq orm "drizzle")}}
        // Implement Drizzle user lookup
        const userList = await db.select().from(users).where(
          eq(users.email, credentials.email as string)
        );
        
        const user = userList[0];
        if (!user || !user.password) {
          return null;
        }

        const isPasswordValid = await bcrypt.compare(
          credentials.password as string,
          user.password
        );

        if (!isPasswordValid) {
          return null;
        }

        return {
          id: user.id,
          email: user.email,
          name: user.name,
        };
        {{else}}
        {{#if (and database (ne database "none"))}}
        {{#if (eq database "postgres")}}
        // Direct PostgreSQL query - you may want to implement proper user lookup here
        try {
          const queryResult = await pool.query(
            'SELECT id, email, name, password FROM users WHERE email = $1',
            [credentials.email]
          );
          
          const user = queryResult.rows[0];
          if (!user || !user.password) {
            return null;
          }

          const isPasswordValid = await bcrypt.compare(
            credentials.password as string,
            user.password
          );

          if (!isPasswordValid) {
            return null;
          }

          return {
            id: user.id,
            email: user.email,
            name: user.name,
          };
        } catch (error) {
          console.error("Database auth error:", error);
          return null;
        }
        {{else}}
        // Implement direct database lookup based on your database
        // This is a placeholder - implement according to your database
        return null;
        {{/if}}
        {{else}}
        // No database configured
        return null;
        {{/if}}
        {{/if}}
      },
    }),
    GitHub({
      clientId: process.env.GITHUB_CLIENT_ID ?? "",
      clientSecret: process.env.GITHUB_CLIENT_SECRET ?? "",
    }),
    Google({
      clientId: process.env.GOOGLE_CLIENT_ID ?? "",
      clientSecret: process.env.GOOGLE_CLIENT_SECRET ?? "",
    }),
  ],
  session: {
    strategy: "jwt" as const,
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },
  pages: {
    signIn: "/auth/signin",
    error: "/auth/error",
  },
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id;
        token.email = user.email;
        token.name = user.name;
      }
      return token;
    },
    async session({ session, token }) {
      if (token && session.user) {
        session.user.id = token.id as string;
        session.user.email = token.email as string;
        session.user.name = token.name as string;
      }
      return session;
    },
  },
  debug: process.env.NODE_ENV === "development",
  secret: process.env.AUTH_SECRET,
  trustHost: true,
  basePath: "/api/auth",
};

// Export handlers and auth functions using Auth.js Core API
export const handlers = {
  GET: (request: Request) => Auth(request, authConfig),
  POST: (request: Request) => Auth(request, authConfig)
};

export const auth = (request: Request) => Auth(request, authConfig);

// For sign in/out, we can create wrapper functions
export const signIn = async (request: Request) => Auth(request, authConfig);
export const signOut = async (request: Request) => Auth(request, authConfig);