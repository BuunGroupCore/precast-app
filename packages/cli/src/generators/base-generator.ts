import fs from "fs/promises";
import path from "path";

import { consola } from "consola";
import { logger } from "../utils/logger.js";

import { type ProjectConfig } from "../../../shared/stack-config.js";

import { getPluginManager } from "@/core/plugin-manager.js";
import { createTemplateEngine } from "@/core/template-engine.js";
import { generateBackendTemplate } from "@/generators/backend-generator.js";
import { getTemplateRoot } from "@/utils/template-path.js";

/**
 * Map framework names to their new directory structure
 */
function getFrameworkPath(framework: string): string {
  const frameworkMap: Record<string, string> = {
    // React ecosystem
    react: "react/bare",
    "react-router": "react/router-v7",
    "react-native": "react/native",
    next: "react/next",
    "tanstack-router": "react/tanstack-router",
    "tanstack-start": "react/tanstack-start",
    "vite-react": "react/vite",

    // Vue ecosystem
    vue: "vue/bare",
    nuxt: "vue/nuxt",
    "vite-vue": "vue/vite",

    // Svelte ecosystem
    svelte: "svelte/bare",
    "vite-svelte": "svelte/vite",

    // Solid ecosystem
    solid: "solid/bare",
    "vite-solid": "solid/vite",

    // Vanilla ecosystem
    vanilla: "vanilla/bare",
    "vite-vanilla": "vanilla/vite",

    // Standalone frameworks
    angular: "angular",
    astro: "astro",
    vite: "vite",
  };

  return frameworkMap[framework] || framework;
}

/**
 * Generate package.json file for a project
 * @param config - Project configuration
 * @param projectPath - Project directory path
 * @param dependencies - Runtime dependencies
 * @param devDependencies - Development dependencies
 * @param additionalFields - Additional package.json fields
 */
export async function generatePackageJson(
  config: ProjectConfig,
  projectPath: string,
  dependencies: string[] = [],
  devDependencies: string[] = [],
  additionalFields: Record<string, any> = {}
): Promise<void> {
  const packageJson = {
    name: config.name,
    version: "0.1.0",
    private: true,
    description: `${config.framework} application generated by create-precast-app`,
    ...additionalFields,
    dependencies: dependencies.reduce(
      (acc, dep) => {
        acc[dep] = "latest";
        return acc;
      },
      {} as Record<string, string>
    ),
    devDependencies: devDependencies.reduce(
      (acc, dep) => {
        acc[dep] = "latest";
        return acc;
      },
      {} as Record<string, string>
    ),
  };

  await fs.writeFile(path.join(projectPath, "package.json"), JSON.stringify(packageJson, null, 2));
}

/**
 * Generate the base template for a framework
 * @param framework - Framework name
 * @param config - Project configuration
 * @param projectPath - Project directory path
 * @param additionalDirs - Additional directories to copy
 */
export async function generateBaseTemplate(
  framework: string,
  config: ProjectConfig,
  projectPath: string,
  additionalDirs: { source: string; dest: string }[] = []
) {
  const templateRoot = getTemplateRoot();
  const templateEngine = createTemplateEngine(templateRoot);
  const pluginManager = getPluginManager();

  const isMonorepo = config.backend && config.backend !== "none" && config.backend !== "next-api";

  const context = {
    config,
    projectPath,
    templateEngine,
    logger: consola,
  };

  try {
    await pluginManager.runPreGenerate(context);

    if (isMonorepo) {
      await generateMonorepoProject(framework, config, projectPath, templateEngine);
    } else {
      await generateSingleAppProject(framework, config, projectPath, templateEngine);
    }

    for (const dir of additionalDirs) {
      await templateEngine.copyTemplateDirectory(
        dir.source,
        path.join(projectPath, dir.dest),
        config,
        { overwrite: true }
      );
    }

    await pluginManager.runGenerate(context);
    await pluginManager.runPostGenerate(context);

    logger.verbose(
      `${framework.charAt(0).toUpperCase() + framework.slice(1)} project generated successfully!`
    );
  } catch (error) {
    consola.error(`Failed to generate ${framework} project:`, error);
    throw error;
  }
}

/**
 * Generate a single application project structure
 * @param framework - Framework name
 * @param config - Project configuration
 * @param projectPath - Project directory path
 * @param templateEngine - Template engine instance
 */
async function generateSingleAppProject(
  framework: string,
  config: ProjectConfig,
  projectPath: string,
  templateEngine: any
) {
  const frameworkPath = getFrameworkPath(framework);
  await templateEngine.copyTemplateDirectory(
    `frameworks/${frameworkPath}/base`,
    projectPath,
    config,
    {
      overwrite: true,
    }
  );

  // Copy common public assets first (for all frameworks)
  const commonPublicDir = `common/public`;
  const extendedConfig = {
    ...config,
    currentDate: new Date().toISOString().split("T")[0], // Add current date for sitemap
  };
  await templateEngine.copyTemplateDirectory(
    commonPublicDir,
    path.join(projectPath, "public"),
    extendedConfig,
    {
      overwrite: false, // Don't overwrite framework-specific files
    }
  );

  // Copy common styles (globals.css, etc.)
  const commonStylesDir = `common/styles`;
  try {
    await templateEngine.copyTemplateDirectory(
      commonStylesDir,
      path.join(projectPath, "src/styles"),
      config,
      {
        overwrite: false, // Don't overwrite framework-specific styles
      }
    );
  } catch (error) {
    consola.debug(`Common styles not found or error copying: ${error}`);
  }

  // Copy common pages (home, not-found, etc.)
  const commonPagesDir = `common/pages`;
  try {
    await templateEngine.copyTemplateDirectory(
      commonPagesDir,
      path.join(projectPath, "src/pages"),
      config,
      {
        overwrite: true, // Overwrite framework-specific pages with common ones
      }
    );
  } catch (error) {
    consola.debug(`Common pages not found or error copying: ${error}`);
  }

  // Copy src directory if it exists (for all frameworks including TanStack Start)
  const srcDir = `frameworks/${frameworkPath}/src`;
  if (
    await templateEngine
      .getAvailableTemplates(`frameworks/${frameworkPath}`)
      .then((dirs: string[]) => dirs.includes("src"))
  ) {
    await templateEngine.copyTemplateDirectory(srcDir, path.join(projectPath, "src"), config, {
      overwrite: true,
    });
  }

  // Copy common components (PrecastBanner, etc.) AFTER framework src
  const commonComponentsDir = `common/components`;
  try {
    const componentsPath = path.join(projectPath, "src/components");

    await templateEngine.copyTemplateDirectory(commonComponentsDir, componentsPath, config, {
      overwrite: false, // Don't overwrite framework-specific components
    });
  } catch (error) {
    // Log but don't fail if common components don't exist
    consola.debug(`Common components not found or error copying: ${error}`);
  }

  // Copy common config directory (constants.ts, etc.)
  const commonConfigDir = `common/config`;
  try {
    await templateEngine.copyTemplateDirectory(
      commonConfigDir,
      path.join(projectPath, "src/config"),
      config,
      {
        overwrite: false, // Don't overwrite framework-specific config
      }
    );
  } catch (error) {
    // Log but don't fail if common config doesn't exist
    consola.debug(`Common config not found or error copying: ${error}`);
  }

  // Copy vite-env.d.ts for Vite-based frameworks
  if (framework !== "next" && framework !== "nuxt") {
    try {
      await templateEngine.copyTemplate(
        "common/vite-env.d.ts.hbs",
        path.join(projectPath, "src/vite-env.d.ts"),
        config
      );
    } catch (error) {
      consola.debug(`vite-env.d.ts not found or error copying: ${error}`);
    }
  }

  const publicDir = `frameworks/${frameworkPath}/public`;
  if (
    await templateEngine
      .getAvailableTemplates(`frameworks/${frameworkPath}`)
      .then((dirs: string[]) => dirs.includes("public"))
  ) {
    await templateEngine.copyTemplateDirectory(
      publicDir,
      path.join(projectPath, "public"),
      config,
      {
        overwrite: true,
      }
    );
  }
}

/**
 * Generate a monorepo project structure with separate frontend and backend
 * @param framework - Frontend framework name
 * @param config - Project configuration
 * @param projectPath - Project directory path
 * @param templateEngine - Template engine instance
 */
async function generateMonorepoProject(
  framework: string,
  config: ProjectConfig,
  projectPath: string,
  templateEngine: any
) {
  logger.verbose("Generating monorepo structure...");

  const frameworkPath = getFrameworkPath(framework);

  await templateEngine.copyTemplateDirectory("workspace", projectPath, config, {
    overwrite: true,
  });

  const appsDir = path.join(projectPath, "apps");

  await fs.mkdir(appsDir, { recursive: true });

  const webDir = path.join(appsDir, "web");
  await fs.mkdir(webDir, { recursive: true });

  await templateEngine.copyTemplateDirectory(`frameworks/${frameworkPath}/base`, webDir, config, {
    overwrite: true,
  });

  // Copy common public assets first (for all frameworks)
  const commonPublicDir = `common/public`;
  const extendedConfig = {
    ...config,
    currentDate: new Date().toISOString().split("T")[0], // Add current date for sitemap
  };
  await templateEngine.copyTemplateDirectory(
    commonPublicDir,
    path.join(webDir, "public"),
    extendedConfig,
    {
      overwrite: false, // Don't overwrite framework-specific files
    }
  );

  // Handle TanStack Start's app directory structure
  if (framework === "tanstack-start") {
    const appDir = `frameworks/${frameworkPath}/app`;
    if (
      await templateEngine
        .getAvailableTemplates(`frameworks/${frameworkPath}`)
        .then((dirs: string[]) => dirs.includes("app"))
    ) {
      await templateEngine.copyTemplateDirectory(appDir, path.join(webDir, "app"), config, {
        overwrite: true,
      });
    }
  } else {
    const srcDir = `frameworks/${frameworkPath}/src`;
    if (
      await templateEngine
        .getAvailableTemplates(`frameworks/${frameworkPath}`)
        .then((dirs: string[]) => dirs.includes("src"))
    ) {
      await templateEngine.copyTemplateDirectory(srcDir, path.join(webDir, "src"), config, {
        overwrite: true,
      });
    }
  }

  // Copy common styles (globals.css, etc.) for monorepo
  const commonStylesDir = `common/styles`;
  try {
    const stylesPath =
      framework === "tanstack-start"
        ? path.join(webDir, "app/styles")
        : path.join(webDir, "src/styles");

    await templateEngine.copyTemplateDirectory(commonStylesDir, stylesPath, config, {
      overwrite: false, // Don't overwrite framework-specific styles
    });
  } catch (error) {
    consola.debug(`Common styles not found or error copying: ${error}`);
  }

  // Copy common pages (home, not-found, etc.) for monorepo
  const commonPagesDir = `common/pages`;
  try {
    const pagesPath =
      framework === "tanstack-start"
        ? path.join(webDir, "app/pages")
        : path.join(webDir, "src/pages");

    await templateEngine.copyTemplateDirectory(commonPagesDir, pagesPath, config, {
      overwrite: true, // Overwrite framework-specific pages with common ones
    });
  } catch (error) {
    consola.debug(`Common pages not found or error copying: ${error}`);
  }

  // Copy common components (PrecastBanner, etc.) AFTER framework src/app
  const commonComponentsDir = `common/components`;
  try {
    const componentsPath =
      framework === "tanstack-start"
        ? path.join(webDir, "app/components")
        : path.join(webDir, "src/components");

    await templateEngine.copyTemplateDirectory(commonComponentsDir, componentsPath, config, {
      overwrite: false, // Don't overwrite framework-specific components
    });
  } catch (error) {
    // Log but don't fail if common components don't exist
    consola.debug(`Common components not found or error copying: ${error}`);
  }

  // Copy common config directory (constants.ts, etc.) for monorepo
  const commonConfigDir = `common/config`;
  try {
    const configPath =
      framework === "tanstack-start"
        ? path.join(webDir, "app/config")
        : path.join(webDir, "src/config");

    await templateEngine.copyTemplateDirectory(commonConfigDir, configPath, config, {
      overwrite: false, // Don't overwrite framework-specific config
    });
  } catch (error) {
    // Log but don't fail if common config doesn't exist
    consola.debug(`Common config not found or error copying: ${error}`);
  }

  // Copy vite-env.d.ts for Vite-based frameworks in monorepo
  if (framework !== "next" && framework !== "nuxt") {
    try {
      const viteEnvPath =
        framework === "tanstack-start"
          ? path.join(webDir, "app/vite-env.d.ts")
          : path.join(webDir, "src/vite-env.d.ts");
      await templateEngine.copyTemplate("common/vite-env.d.ts.hbs", viteEnvPath, config);
    } catch (error) {
      consola.debug(`vite-env.d.ts not found or error copying: ${error}`);
    }
  }

  const publicDir = `frameworks/${frameworkPath}/public`;
  if (
    await templateEngine
      .getAvailableTemplates(`frameworks/${frameworkPath}`)
      .then((dirs: string[]) => dirs.includes("public"))
  ) {
    await templateEngine.copyTemplateDirectory(publicDir, path.join(webDir, "public"), config, {
      overwrite: true,
    });
  }

  if (config.backend && config.backend !== "none") {
    // Use "workers" folder for cloudflare-workers, "api" for everything else
    const backendFolderName = config.backend === "cloudflare-workers" ? "workers" : "api";
    const apiDir = path.join(appsDir, backendFolderName);
    await fs.mkdir(apiDir, { recursive: true });
    await generateBackendTemplate(config.backend, config, apiDir);

    // Create packages/shared for monorepo structure
    const packagesDir = path.join(projectPath, "packages");
    const sharedDir = path.join(packagesDir, "shared");
    await fs.mkdir(packagesDir, { recursive: true });
    await fs.mkdir(sharedDir, { recursive: true });

    // Copy shared package templates
    await templateEngine.copyTemplateDirectory("packages/shared", sharedDir, config, {
      overwrite: true,
    });

    // Add shared package as dependency to both web and api
    const webPackageJsonPath = path.join(webDir, "package.json");
    const apiPackageJsonPath = path.join(apiDir, "package.json");
    const sharedPackageName = `@${config.name}/shared`;

    // Update web package.json
    if (
      await fs
        .access(webPackageJsonPath)
        .then(() => true)
        .catch(() => false)
    ) {
      const webPackageJson = JSON.parse(await fs.readFile(webPackageJsonPath, "utf-8"));
      webPackageJson.dependencies = webPackageJson.dependencies || {};
      webPackageJson.dependencies[sharedPackageName] = "workspace:*";
      await fs.writeFile(webPackageJsonPath, JSON.stringify(webPackageJson, null, 2));
    }

    // Update api package.json
    if (
      await fs
        .access(apiPackageJsonPath)
        .then(() => true)
        .catch(() => false)
    ) {
      const apiPackageJson = JSON.parse(await fs.readFile(apiPackageJsonPath, "utf-8"));
      apiPackageJson.dependencies = apiPackageJson.dependencies || {};
      apiPackageJson.dependencies[sharedPackageName] = "workspace:*";
      await fs.writeFile(apiPackageJsonPath, JSON.stringify(apiPackageJson, null, 2));
    }

    logger.verbose("Created packages/shared for type sharing between apps");
  }

  logger.verbose("Monorepo structure created successfully!");
}
